#设计模式原则
###开闭原则
对扩展开放，对修改关闭
###里氏代换原则
子类可以拓展父类的功能，但是不能修改父类原有的功能
###依赖倒转原则
高层模块不应该依赖低层模块，二者都应该依赖其抽象
抽象不应该依赖细节，细节应该依赖抽象
###接口隔离原则
客户端不应该被迫依赖于他不使用的方法
一个类对另一个类的依赖应该建立在最小的接口上
###迪米特法则
如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合关系，提高模块的相互独立性。
###合成复用原则
尽量先使用组合或者聚合等关联关系来实现，其次再考虑使用继承关系来实现
#设计模式
##创建者模式
###单例模式
饿汉式：类加载就会导致该实例对象被创建
懒汉式：类加载不会导致该单例对象被创建，而是首次使用该对象时才会被创建
###工厂模式
####简单工厂
####静态工厂
####工厂方法
####抽象工厂
抽象工厂模式包括：
1.抽象工厂
2.具体工厂
3.抽象产品
4.具体产品
###原型模式
用一个已经创建的实例作为原型，通过复制该原型对象创建一个和原型对象相同的对象
浅克隆：对于基本数据类型，会直接复制值给拷贝对象；对于引用数据类型，只拷贝对象地址，指向原来对象的地址
深克隆：无论基本类型还是引用类型，全部拷贝为一个新的对象，属性中引用的其他对象也会被拷贝，不指向原有对象的地址
###建造者模式
将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示
##结构型模式
###代理模式
代理模式分为三种角色：
1.抽象主题类
2.真实主题类
3.代理类
###适配器模式
####类适配器模式
####对象适配器模式
适配器模式包含三种角色
1.目标接口：当前系统业务所期待的接口，它可以是抽象类或者接口
2.适配者类：它是被访问和适配的现存组件库中的组件接口
3.适配器类：它是一个转换器，通过继承或者引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者
###装饰者模式
装饰者模式中的角色
1.抽象构件角色：定义一个抽象接口规范准备接收附加责任的对象
2.具体构件角色：实现抽象构件，通过装饰角色为其添加一些职责
3.抽象装饰角色：继承或实现抽象构件，并包含具体构件的实例，可以通过其子类扩展构件的功能
4.具体装饰角色：实现抽象装饰的相关方法，并给具体构件对象添加附件的责任
###桥接模式
1.抽象化角色：定义抽象类，并包含一个对实现化对象的引用
2.扩展抽象化角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法
3.实现化角色：定义现实化角色的接口，供扩展抽象化角色调用
4.具体实现化角色：给出实现化角色接口的具体实现
###外观模式
外观模式包含角色
1.外观角色：为多个子系统对外提供一个共同的接口与
2.子系统角色：实现系统的部分功能，客户可以通过外观角色访问它
###组合模式
组合模式包含角色
1.抽象根节点：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性
2.树枝节点：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成树形结构
3.叶子节点：叶子节点对象，其下再无分支，是系统层次遍历的最小单位
###享元模式
1.抽象享元角色：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）
2.具体享元角色：它实现了抽象享元类，称为享元对象；在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象
3.非享元角色：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建
4.享元工厂角色：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象
