#设计模式资料
https://bright-boy.gitee.io/technical-notes/#/%E8%AE%BE%E8%AE%A1%E6%A8%A1%E5%BC%8F/index
(不是本人撰写，link别人的博客)
#设计模式原则
###开闭原则
对扩展开放，对修改关闭
###里氏代换原则
子类可以拓展父类的功能，但是不能修改父类原有的功能
###依赖倒转原则
高层模块不应该依赖低层模块，二者都应该依赖其抽象
抽象不应该依赖细节，细节应该依赖抽象
###接口隔离原则
客户端不应该被迫依赖于他不使用的方法
一个类对另一个类的依赖应该建立在最小的接口上
###迪米特法则
如果两个软件实体无须直接通信，那么就不应当发生直接的相互调用，可以通过第三方转发该调用。其目的是降低类之间的耦合关系，提高模块的相互独立性。
###合成复用原则
尽量先使用组合或者聚合等关联关系来实现，其次再考虑使用继承关系来实现
#设计模式
##创建者模式
###单例模式
饿汉式：类加载就会导致该实例对象被创建
懒汉式：类加载不会导致该单例对象被创建，而是首次使用该对象时才会被创建
###工厂模式
####简单工厂
####静态工厂
####工厂方法
####抽象工厂
抽象工厂模式包括：
1.抽象工厂
2.具体工厂
3.抽象产品
4.具体产品
###原型模式
用一个已经创建的实例作为原型，通过复制该原型对象创建一个和原型对象相同的对象
浅克隆：对于基本数据类型，会直接复制值给拷贝对象；对于引用数据类型，只拷贝对象地址，指向原来对象的地址
深克隆：无论基本类型还是引用类型，全部拷贝为一个新的对象，属性中引用的其他对象也会被拷贝，不指向原有对象的地址
###建造者模式
将一个复杂对象的构建与表示分离，使得同样的构建过程可以创建不同的表示
##结构型模式
###代理模式
代理模式分为三种角色：
1.抽象主题类
2.真实主题类
3.代理类
###适配器模式
####类适配器模式
####对象适配器模式
适配器模式包含三种角色
1.目标接口：当前系统业务所期待的接口，它可以是抽象类或者接口
2.适配者类：它是被访问和适配的现存组件库中的组件接口
3.适配器类：它是一个转换器，通过继承或者引用适配者的对象，把适配者接口转换成目标接口，让客户按目标接口的格式访问适配者
###装饰者模式
装饰者模式中的角色
1.抽象构件角色：定义一个抽象接口规范准备接收附加责任的对象
2.具体构件角色：实现抽象构件，通过装饰角色为其添加一些职责
3.抽象装饰角色：继承或实现抽象构件，并包含具体构件的实例，可以通过其子类扩展构件的功能
4.具体装饰角色：实现抽象装饰的相关方法，并给具体构件对象添加附件的责任
###桥接模式
1.抽象化角色：定义抽象类，并包含一个对实现化对象的引用
2.扩展抽象化角色：是抽象化角色的子类，实现父类中的业务方法，并通过组合关系调用实现化角色中的业务方法
3.实现化角色：定义现实化角色的接口，供扩展抽象化角色调用
4.具体实现化角色：给出实现化角色接口的具体实现
###外观模式
外观模式包含角色
1.外观角色：为多个子系统对外提供一个共同的接口与
2.子系统角色：实现系统的部分功能，客户可以通过外观角色访问它
###组合模式
组合模式包含角色
1.抽象根节点：定义系统各层次对象的共有方法和属性，可以预先定义一些默认行为和属性
2.树枝节点：定义树枝节点的行为，存储子节点，组合树枝节点和叶子节点形成树形结构
3.叶子节点：叶子节点对象，其下再无分支，是系统层次遍历的最小单位
###享元模式
1.抽象享元角色：通常是一个接口或抽象类，在抽象享元类中声明了具体享元类公共的方法，这些方法可以向外界提供享元对象的内部数据（内部状态），同时也可以通过这些方法来设置外部数据（外部状态）
2.具体享元角色：它实现了抽象享元类，称为享元对象；在具体享元类中为内部状态提供了存储空间。通常我们可以结合单例模式来设计具体享元类，为每一个具体享元类提供唯一的享元对象
3.非享元角色：并不是所有的抽象享元类的子类都需要被共享，不能被共享的子类可设计为非共享具体享元类；当需要一个非共享具体享元类的对象时可以直接通过实例化创建
4.享元工厂角色：负责创建和管理享元角色。当客户对象请求一个享元对象时，享元工厂检査系统中是否存在符合要求的享元对象，如果存在则提供给客户；如果不存在的话，则创建一个新的享元对象
##行为型模式
###模板方法模式
1.抽象类
2.具体子类
###策略模式
1.抽象策略类：这是一个抽象角色，通常由一个接口或者抽象类实现。此角色给出所有的具体策略类所需接口。
2.具体策略类：实现了抽象策略定义的接口，提供具体的算法实现或者行为。
3.环境类：持有一个策略类的引用，最终给客户端调用
###命令模式
1.抽象命令类角色
2.具体命令角色
3.实现者/接收者角色
4.调用者/请求者角色
###责任链模式
1.抽象处理者角色：定义一个处理请求的接口，包含抽象处理方法和一个后继连接
2.具体处理者角色：实现抽象处理者的处理方法，判断能否处理本次请求，如果可以处理请求则处理，否则将该请求转给它的后继者
3.客户类角色：创建数据链，并向链头的具体处理者对象提交请求，他不关心处理细节和请求的传递过程
###状态模式
1.环境角色：也称上下文，它定义了客户程序需要的接口，维护一个当前状态，并将与状态相关的操作委托给当前状态对象处理
2.抽象状态角色：定义一个接口，用以封装环境对象中的特定状态所对应的行为
3.具体状态角色：实现抽象状态所对应的行为
###观察者模式
1.抽象被观察者
2.具体被观察者
3.抽象观察者
4.具体观察者
###中介者模式